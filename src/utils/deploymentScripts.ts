import type { Server } from '@/types';
import type { ExportResult } from './exportConfig';
import { configToJson } from './exportConfig';

export type ScriptType = 'bash' | 'docker-compose' | 'ansible';

export interface DeploymentResult {
  filename: string;
  content: string;
  type: ScriptType;
}

// ── Credentials (transient, never stored in project) ──

export interface ServerCredentials {
  serverId: string;
  sshUser: string;
  authMethod: 'key' | 'password';
  sshKeyPath?: string;
}

// ── Bash Script Generator ──

function generateBashScript(
  servers: Server[],
  configs: ExportResult[],
  credentials: ServerCredentials[]
): string {
  const lines: string[] = [
    '#!/bin/bash',
    '# Generated by Xray Graph Builder',
    '# Deploy xray infrastructure using Docker',
    '',
    'set -euo pipefail',
    '',
    '# ═══════════════════════════════════════',
    '# Server Credentials',
    '# ═══════════════════════════════════════',
    '',
  ];

  // Variable declarations for each server
  for (const server of servers) {
    const cred = credentials.find((c) => c.serverId === server.id);
    const varName = sanitizeVarName(server.name);
    lines.push(`${varName}_HOST="${server.host}"`);
    lines.push(`${varName}_USER="${cred?.sshUser || server.sshUser || 'root'}"`);
    lines.push(`${varName}_PORT="${server.sshPort || 22}"`);
    if (cred?.authMethod === 'key') {
      lines.push(`${varName}_SSH_KEY="${cred.sshKeyPath || '~/.ssh/id_rsa'}"`);
    }
    lines.push('');
  }

  // Write configs to temp files
  lines.push(
    '# ═══════════════════════════════════════',
    '# Write Configs',
    '# ═══════════════════════════════════════',
    '',
    'SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"',
    '',
  );

  for (const config of configs) {
    lines.push(`cat > "$SCRIPT_DIR/${config.filename}" << 'XRAY_CONFIG_EOF'`);
    lines.push(configToJson(config.config));
    lines.push('XRAY_CONFIG_EOF');
    lines.push(`echo "Wrote ${config.filename}"`);
    lines.push('');
  }

  // Deploy function for each server
  lines.push(
    '# ═══════════════════════════════════════',
    '# Deploy Functions',
    '# ═══════════════════════════════════════',
    '',
  );

  for (let i = 0; i < servers.length; i++) {
    const server = servers[i]!;
    const config = configs[i] || configs[0];
    if (!config) continue;

    const varName = sanitizeVarName(server.name);
    const cred = credentials.find((c) => c.serverId === server.id);
    const sshKeyOpt = cred?.authMethod === 'key'
      ? ` -i "$${varName}_SSH_KEY"`
      : '';

    lines.push(`deploy_${varName.toLowerCase()}() {`);
    lines.push(`  echo ""`);
    lines.push(`  echo "Deploying to ${server.name} ($${varName}_HOST)..."`);
    lines.push(`  echo "═══════════════════════════════════════"`);
    lines.push('');
    lines.push(`  # Copy config to server`);
    lines.push(`  scp${sshKeyOpt} -P "$${varName}_PORT" \\`);
    lines.push(`    "$SCRIPT_DIR/${config.filename}" \\`);
    lines.push(`    "$${varName}_USER@$${varName}_HOST:/tmp/xray_config.json"`);
    lines.push('');
    lines.push(`  # Deploy via SSH`);
    lines.push(`  ssh${sshKeyOpt} -p "$${varName}_PORT" "$${varName}_USER@$${varName}_HOST" << 'DEPLOY_EOF'`);
    lines.push('    # Install Docker if needed');
    lines.push('    if ! command -v docker &> /dev/null; then');
    lines.push('      echo "Installing Docker..."');
    lines.push('      curl -fsSL https://get.docker.com | sh');
    lines.push('    fi');
    lines.push('');
    lines.push('    # Create config directory');
    lines.push('    mkdir -p /etc/xray');
    lines.push('    mv /tmp/xray_config.json /etc/xray/config.json');
    lines.push('');
    lines.push('    # Stop existing container');
    lines.push('    docker stop xray 2>/dev/null || true');
    lines.push('    docker rm xray 2>/dev/null || true');
    lines.push('');
    lines.push('    # Run xray container');
    lines.push('    docker run -d \\');
    lines.push('      --name xray \\');
    lines.push('      --restart=unless-stopped \\');
    lines.push('      -v /etc/xray/config.json:/etc/xray/config.json:ro \\');

    // Determine ports from config
    const ports = getInboundPorts(config);
    for (const port of ports) {
      lines.push(`      -p ${port}:${port} \\`);
    }

    lines.push('      teddysun/xray');
    lines.push('');
    lines.push('    # Verify');
    lines.push('    sleep 2');
    lines.push('    if docker ps | grep -q xray; then');
    lines.push(`      echo "Deployed to ${server.name} successfully!"`);
    lines.push('    else');
    lines.push(`      echo "ERROR: Container failed to start on ${server.name}"`);
    lines.push('      docker logs xray');
    lines.push('      exit 1');
    lines.push('    fi');
    lines.push('DEPLOY_EOF');
    lines.push('}');
    lines.push('');
  }

  // Main execution
  lines.push(
    '# ═══════════════════════════════════════',
    '# Execute Deployment',
    '# ═══════════════════════════════════════',
    '',
    'echo "Xray Graph Builder — Deployment Script"',
    'echo "═══════════════════════════════════════"',
    '',
  );

  for (const server of servers) {
    const varName = sanitizeVarName(server.name);
    lines.push(`deploy_${varName.toLowerCase()}`);
  }

  lines.push('');
  lines.push('echo ""');
  lines.push('echo "All servers deployed successfully!"');
  lines.push('');

  return lines.join('\n');
}

// ── Docker Compose Generator ──

function generateDockerCompose(
  server: Server,
  config: ExportResult
): string {
  const ports = getInboundPorts(config);
  const portMappings = ports.map((p) => `      - "${p}:${p}"`).join('\n');

  return `# Docker Compose for ${server.name} (${server.host})
# Generated by Xray Graph Builder
version: '3.8'

services:
  xray:
    image: teddysun/xray
    container_name: xray
    restart: unless-stopped
    volumes:
      - ./config.json:/etc/xray/config.json:ro
    ports:
${portMappings}
    networks:
      - xray-network

networks:
  xray-network:
    driver: bridge
`;
}

// ── Ansible Playbook Generator ──

function generateAnsiblePlaybook(
  servers: Server[],
  configs: ExportResult[],
  credentials: ServerCredentials[]
): string {
  // Determine ports across all configs
  const allPorts = new Set<number>();
  for (const config of configs) {
    for (const port of getInboundPorts(config)) {
      allPorts.add(port);
    }
  }

  const portMappings = Array.from(allPorts)
    .map((p) => `          - "${p}:${p}"`)
    .join('\n');

  return `# Ansible Playbook for Xray Infrastructure
# Generated by Xray Graph Builder
---
- name: Deploy Xray infrastructure
  hosts: xray_servers
  become: yes

  tasks:
    - name: Install Docker (Debian/Ubuntu)
      apt:
        name: docker.io
        state: present
        update_cache: yes
      when: ansible_os_family == "Debian"

    - name: Install Docker (RHEL/CentOS)
      yum:
        name: docker
        state: present
      when: ansible_os_family == "RedHat"

    - name: Start Docker service
      service:
        name: docker
        state: started
        enabled: yes

    - name: Create xray config directory
      file:
        path: /etc/xray
        state: directory
        mode: '0755'

    - name: Copy xray config
      copy:
        src: "config_{{ inventory_hostname }}.json"
        dest: /etc/xray/config.json
        mode: '0644'
      notify: Restart xray

    - name: Run xray container
      docker_container:
        name: xray
        image: teddysun/xray
        state: started
        restart_policy: unless-stopped
        volumes:
          - /etc/xray/config.json:/etc/xray/config.json:ro
        ports:
${portMappings}

  handlers:
    - name: Restart xray
      docker_container:
        name: xray
        state: started
        restart: yes
        image: teddysun/xray
        volumes:
          - /etc/xray/config.json:/etc/xray/config.json:ro
        ports:
${portMappings}

---
# inventory.ini
# Generated by Xray Graph Builder
#
# [xray_servers]
${servers.map((s) => {
    const cred = credentials.find((c) => c.serverId === s.id);
    const user = cred?.sshUser || s.sshUser || 'root';
    return `# ${sanitizeVarName(s.name).toLowerCase()} ansible_host=${s.host} ansible_user=${user} ansible_port=${s.sshPort || 22}`;
  }).join('\n')}
`;
}

function generateAnsibleInventory(
  servers: Server[],
  credentials: ServerCredentials[]
): string {
  const lines = [
    '# Ansible Inventory',
    '# Generated by Xray Graph Builder',
    '',
    '[xray_servers]',
  ];

  for (const server of servers) {
    const cred = credentials.find((c) => c.serverId === server.id);
    const user = cred?.sshUser || server.sshUser || 'root';
    const name = sanitizeVarName(server.name).toLowerCase();
    lines.push(`${name} ansible_host=${server.host} ansible_user=${user} ansible_port=${server.sshPort || 22}`);
  }

  return lines.join('\n') + '\n';
}

// ── Helpers ──

function sanitizeVarName(name: string): string {
  return name
    .toUpperCase()
    .replace(/[^A-Z0-9]/g, '_')
    .replace(/^[0-9]/, '_$&')
    .replace(/_+/g, '_');
}

function getInboundPorts(config: ExportResult): number[] {
  const ports = config.config.inbounds
    .map((ib) => ib.port)
    .filter((p): p is number => typeof p === 'number' && p > 0);

  // Deduplicate
  return [...new Set(ports)];
}

// ── Main Export Functions ──

export function generateDeploymentScripts(
  servers: Server[],
  configs: ExportResult[],
  credentials: ServerCredentials[],
  type: ScriptType
): DeploymentResult[] {
  switch (type) {
    case 'bash':
      return [{
        filename: 'deploy.sh',
        content: generateBashScript(servers, configs, credentials),
        type: 'bash',
      }];

    case 'docker-compose': {
      const results: DeploymentResult[] = [];
      for (let i = 0; i < servers.length; i++) {
        const server = servers[i]!;
        const config = configs[i] || configs[0];
        if (!config) continue;

        const suffix = servers.length > 1 ? `-${sanitizeVarName(server.name).toLowerCase()}` : '';
        results.push({
          filename: `docker-compose${suffix}.yml`,
          content: generateDockerCompose(server, config),
          type: 'docker-compose',
        });
      }
      return results;
    }

    case 'ansible':
      return [
        {
          filename: 'playbook.yml',
          content: generateAnsiblePlaybook(servers, configs, credentials),
          type: 'ansible',
        },
        {
          filename: 'inventory.ini',
          content: generateAnsibleInventory(servers, credentials),
          type: 'ansible',
        },
      ];
  }
}
